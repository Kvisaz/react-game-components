# 10 - Tic Tac Toe - Крестики-нолики на React

- [Проверка выполнения](report.md) 

Сложный компонент за 500

#### Требования
* писать компоненты в папке components
* Для каждого компонента создать отдельный файл `.tsx` и соответствующий файл `.stories.tsx` для Storybook.
* Использовать TypeScript для типизации пропсов.
* писать чистый и понятный код
* разрешается использовать ранее сделанные компоненты, если они подходят по функционалу без доработок
* если нужны встроенные компоненты для текущего компонента - складывай их внутри собственной папки components в папке component
* разрешается вовсе не использовать компоненты и городить пока сколь угодно сложное дерево JSX,  если в задаче не сказано обратное
* условия задачи имеют приоритет над описанными общими требованиями


## Описание задачи
Создайте игру "Крестики-нолики" (Tic-Tac-Toe) используя React и TypeScript. Это упражнение поможет вам понять основы работы с состоянием в React, использование функциональных компонентов и хуков, а также применение более сложных концепций, таких как контекст и редьюсер.

## Требования

1. Используйте функциональные компоненты React.
2. Используйте хук useState для локального состояния компонентов.
3. Примените useContext и useReducer для управления глобальным состоянием игры и передачи его между компонентами.
4. Реализуйте логику игры согласно правилам крестиков-ноликов.
5. Отображайте статус игры (чей ход, кто выиграл или ничья).
6. Добавьте кнопку для начала новой игры.
7. Используйте TypeScript для типизации пропсов, состояния и функций.

## Структура приложения

Разделите приложение на следующие компоненты:

1. `TicTacToeGame`: Основной компонент, содержащий глобальное состояние игры и логику.
2. `TicTacToeUi`: Компонент, отображающий интерфейс игры (статус, кнопка новой игры).
3. `TicTacToeField`: Компонент, представляющий игровое поле.
4. `Square`: Компонент, представляющий отдельную клетку на поле.

## Интерфейсы

Используйте следующие интерфейсы в вашем приложении:

```typescript
type SquareValue = 'X' | 'O' | null;

interface GameState {
  squares: SquareValue[];
  xIsNext: boolean;
  winner: SquareValue;
}

type GameAction = 
  | { type: 'MAKE_MOVE'; index: number }
  | { type: 'RESET_GAME' };
```

## Логика игры

1. Игровое поле представляет собой массив из 9 элементов (3x3).
2. Игроки ходят по очереди, начиная с 'X'.
3. Если игрок заполняет три клетки в ряд (по горизонтали, вертикали или диагонали), он выигрывает.
4. Если все клетки заполнены и нет победителя, игра заканчивается вничью.

## Пример использования компонентов

```tsx
import React from 'react';
import TicTacToeGame from './components/TicTacToeGame';

const App: React.FC = () => {
  return (
    <div className="app">
      <h1>Крестики-нолики</h1>
      <TicTacToeGame />
    </div>
  );
};

export default App;
```

## Пример логики работы с игровым полем

Вот пример того, как можно работать с игровым полем на TypeScript:

```typescript
const initialState: GameState = {
  squares: Array(9).fill(null),
  xIsNext: true,
  winner: null,
};

const gameReducer = (state: GameState, action: GameAction): GameState => {
  switch (action.type) {
    case 'MAKE_MOVE':
      if (state.winner || state.squares[action.index]) {
        return state;
      }
      const newSquares = [...state.squares];
      newSquares[action.index] = state.xIsNext ? 'X' : 'O';
      return {
        squares: newSquares,
        xIsNext: !state.xIsNext,
        winner: calculateWinner(newSquares),
      };
    case 'RESET_GAME':
      return initialState;
    default:
      return state;
  }
};

const calculateWinner = (squares: SquareValue[]): SquareValue => {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
};
```

## Отображение текущего игрока

В компоненте `TicTacToeUi` добавьте следующий метод для отображения текущего игрока:

```tsx
const TicTacToeUi: React.FC<{ state: GameState }> = ({ state }) => {
  const getCurrentPlayer = () => {
    return state.xIsNext ? 'X' : 'O';
  };

  return (
    <div className="game-ui">
      <div className="status">
        {state.winner
          ? `Победитель: ${state.winner}`
          : `Текущий игрок: ${getCurrentPlayer()}`}
      </div>
      {/* Остальной UI код */}
    </div>
  );
};
```

## Рекомендации по реализации

1. Начните с создания контекста игры и редьюсера для управления состоянием.
2. Реализуйте компонент `TicTacToeGame`, который будет использовать `useReducer` и предоставлять состояние через контекст.
3. Создайте компонент `Square`, который будет принимать значение и функцию обратного вызова для обработки клика.
4. Реализуйте `TicTacToeField`, который будет отображать сетку из компонентов `Square`.
5. Создайте `TicTacToeUi` для отображения статуса игры и кнопки новой игры.
6. Используйте `useContext` в дочерних компонентах для доступа к состоянию и действиям.

Это упражнение поможет вам понять, как работать с более сложным состоянием в React, использовать контекст для передачи данных между компонентами, а также применять TypeScript для создания типобезопасного кода.


## Приложение: Компонент GameUi

Компонент `GameUi` отвечает за отображение пользовательского интерфейса игры "Крестики-нолики". Он включает в себя информацию о текущем состоянии игры, показывает, чей сейчас ход, и предоставляет возможность начать новую игру.

### Содержимое GameUi

1. **Статус игры**: Текстовое поле, показывающее текущее состояние игры:
    - Чей сейчас ход (например, "Ход игрока X" или "Ход игрока O")
    - Результат игры (например, "Победил игрок X", "Победил игрок O" или "Ничья")

2. **Кнопка рестарта**: Кнопка "Новая игра", которая позволяет начать игру заново в любой момент.

3. **Счет игры**: Опционально можно добавить счетчик побед для каждого игрока.

## Пример реализации

```tsx
import React, { useContext } from 'react';
import { GameContext } from './GameContext';

const GameUi: React.FC = () => {
  const { state, dispatch } = useContext(GameContext);

  const getCurrentPlayer = () => {
    return state.xIsNext ? 'X' : 'O';
  };

  const getGameStatus = () => {
    if (state.winner) {
      return `Победил игрок ${state.winner}`;
    } else if (state.squares.every(square => square !== null)) {
      return 'Ничья';
    } else {
      return `Ход игрока ${getCurrentPlayer()}`;
    }
  };

  const handleRestart = () => {
    dispatch({ type: 'RESET_GAME' });
  };

  return (
    <div className="game-ui">
      <div className="status">{getGameStatus()}</div>
      <button className="restart-button" onClick={handleRestart}>
        Новая игра
      </button>
    </div>
  );
};

export default GameUi;
```

## Расположение кнопки рестарта

Кнопка рестарта должна быть расположена в заметном месте интерфейса, чтобы пользователь мог легко начать новую игру. Рекомендуемые варианты расположения:

1. **Под игровым полем**: Разместите кнопку "Новая игра" непосредственно под игровым полем. Это интуитивно понятное место, так как пользователь обычно смотрит вниз после завершения игры.

2. **Над игровым полем**: Если вы хотите, чтобы кнопка была более заметной, разместите ее над игровым полем, рядом с информацией о текущем состоянии игры.

3. **В правом верхнем углу**: Это стандартное место для кнопок действий в многих интерфейсах.

Пример структуры компонента с кнопкой под игровым полем:

```tsx
const TicTacToeGame: React.FC = () => {
  // ... логика игры ...

  return (
    <div className="tic-tac-toe-game">
      <GameUi />
      <TicTacToeField />
      <button className="restart-button" onClick={handleRestart}>
        Новая игра
      </button>
    </div>
  );
};
```

При таком расположении кнопка рестарта будет легко доступна пользователю, но не будет отвлекать от самого процесса игры.
